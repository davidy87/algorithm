# Counting Sort

<br>

## 개요

### Comparison Sort

N개 원소의 배열이 있을 때, 이를 모두 정렬하는 가짓수는 N! 이다.

따라서, Comparison Sort를 통해 생기는 트리의 말단 노드가 $N!$ 이상의 노드 갯수를 갖기 위해서는,

> `2^h >= N!`

을 만족하는 `h (>= O(nlogn))` 을 가져야 한다.

- `h`는 트리의 높이 → 즉, Comparison sort의 시간 복잡도
- 이런 시간 복잡도를 줄이기 위한 방법: 비교 정렬을 하지 않는 것

### Counting Sort

특정한 범위 안에 있는 key를 바탕으로 정렬하는 방식이다.

**특정한 조건이 부합될 때만** 사용할 수 있지만, 데이터 수가 많더라도 중복된 값이 많이 분포되어 있는 배열을 정렬할 때 효과적이고 빠른 정렬 알고리즘이다.

- 최대, 최소 값 차이가 100만 이하일 경우 효과적이다.

Selection, Insertion, Quick Sort처럼 데이터를 비교하며 위치를 변경하는 **비교 기반의 정렬 알고리즘이 아니다**.

- 따라서, 이런 비교 기반의 정렬 방식보다 더 나은 시간 복잡도를 갖는다.

Counting Sort를 사용 가능한 **특정한 조건**은 아래와 같다.

1. 데이터의 크기 **범위가 제한**된 경우
    - Ex) 0 ~ 100 까지의 점수를 정렬하는 경우

2. 데이터가 **양의 정수**인 경우
    - 데이터가 실수인 경우 무한의 범위를 가질 수 있으므로 1번 조건에 부합하지 못함

3. 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않는 경우
    - 필수적인 조건은 아니지만, 차이가 클 수록 메모리의 사용이 많아짐

<br>

## 동작 방식

1. 배열에 있는 각 원소들의 갯수를 담는 배열 (`counter`)와 정렬 결과를 담을 `output` 배열 생성

2. 위에서 생성한 `counter`를 누적합을 계산하며 변경

3. 정렬할 배열을 역으로 순회하며 `counter` 조회
   - 정렬할 배열을 `arr`라고 가정할 때,
      - `output[counter[arr[i]]] = arr[i];` 수행
   - 위 과정을 반복하면 `output`은 `arr`의 정렬된 상태가 된다.

<br>

## Complexity

### Time Complexity

* `O(N + k)` → `k`는 정렬할 배열에 존재하는 최대 값

### Space Complexity

* `O(N + k)` → `N` 크기의 output 배열 + `k` 크기의 counter 배열

<br>

## 장단점

### 장점

* `O(N)`의 시간 복잡도

### 단점

* Inplace sorting이 아님 → `k`(최대 값) 만큼의 배열을 만들어야 하기 때문에 메모리 소모